# -*- coding: utf-8 -*-
"""loan.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18GvkBdfLsMjr6zi3lmqIRhQPNlYQ7nPY

# Business Case

Kamu diminta untuk membangun model yang dapat **memprediksi credit risk** menggunakan dataset yang disediakan oleh company yang terdiri dari data pinjaman yang diterima dan yang ditolak. Selain itu kamu juga perlu mempersiapkan media visual untuk mempresentasikan solusi ke klien. Pastikan media visual yang kamu buat jelas, mudah dibaca, dan komunikatif.


Tahapan Pengerjaan Tugas:
1. File dataset yang disediakan terdiri dari satu file data (format csv) dan satu data dictionary (format xlsx) yang berisikan informasi mengenai masing-masing kolom yang ada pada file data. Silahkan pelajari informasi mengenai data tersebut untuk mengetahui langkah apa yang perlu dilakukan untuk mempersiapkan data
2. Siapkan tools yang akan kamu gunakan untuk membantu pengerjaan soal seperti yang telah dijelaskan di prerequisite, lalu import data untuk mempersiapkan pengerjaan.
3. Kerjakan tugas dan siapkan seluruh file yang perlu kamu kumpulkan dengan mengacu kepada No. 6
4. Gabung ketiga file yang telah kamu selesaikan dalam satu folder ZIP yang diberi judul "[Nama Lengkap]_VIX_ID/X Partners"
5. Submit tugasmu hanya dalam bentuk folder ZIP sesuai ketentuan di No. 4
6. Terdapat dua skenario pengumpulan tugas berdasarkan bahasa pemrograman yang kamu gunakan untuk mengerjakan final project ini. Silahkan cek dibawah ini untuk detailnya:

Apabila kamu menggunakan Python untuk mengerjakan tugas ini, kamu perlu mengumpulkan:
- File Code dengan format .py
- File Python Notebook dengan format .ipynb
- File infografis sebagai media presentasi end-to-end solution yang telah kamu buat

## Column Details
- annual_income: This feature measures the borrower's annual income. Borrowers with higher incomes are generally considered to be **less risky** because they have more money to repay their loans.

- funded_amount: This feature measures the amount of the loan that was funded. Borrowers who borrow less money are generally considered to be **less risky** because they have less debt to manage.

- grade: This feature is a letter grade that is assigned to the loan by the lender. The grade is based on the lender's assessment of the borrower's creditworthiness and the risk of default. Loans with higher grades are generally considered to be less risky.

- home_ownership: This feature indicates whether the borrower owns or rents their home. Homeowners are generally considered to be less risky because they have more assets and are less likely to move.

- installment: This feature measures the monthly payment on the loan. Borrowers with lower monthly payments are generally considered to be less risky because they are more likely to be able to afford their payments.

- int_rate: This feature measures the interest rate on the loan. Borrowers with lower interest rates are generally considered to be less risky because they are paying less interest on their loans.

- last_payment_amount: This feature measures the amount of the last payment that the borrower made on the loan. Borrowers who have made all of their payments on time and in full are generally considered to be less risky.

- loan_amount: This feature measures the total amount of the loan. Borrowers who borrow less money are generally considered to be less risky because they have less debt to manage.

- member_id: This feature is a unique identifier for the borrower. It is not generally used to predict credit score, but it may be used to identify the borrower in other data sets.

- out_prncp_inv: This feature measures the outstanding principal balance on the loan. Borrowers with lower outstanding balances are generally considered to be less risky.

- purpose: This feature indicates the purpose of the loan (e.g., debt consolidation, home improvement, etc.). Lenders may use this information to assess the borrower's risk of default.

- recoveries: This feature measures the amount of money that the lender has recovered on defaulted loans. Lenders may use this information to assess the borrower's risk of default.

- revol_util: This feature measures the amount of revolving credit that the borrower is using relative to their total available credit. Borrowers with lower revolving credit utilization rates are generally considered to be less risky.

- sub_grade: This feature is a more granular version of the grade feature. It takes into account additional factors, such as the borrower's debt-to-income ratio and credit history length. Loans with higher sub-grades are generally considered to be less risky.

- term: This feature measures the length of the loan in months. Loans with shorter terms are generally considered to be less risky because the borrower has less time to default.

- total_pymnt: This feature measures the total amount that the borrower will repay on the loan, including principal and interest. Borrowers with lower total payments are generally considered to be less risky.

- total_pymnt_inv: This feature measures the total amount of money that the lender has invested in the loan, including principal and interest. Borrowers with lower total investment amounts are generally considered to be less risky.

- total_rec_int: This feature measures the total amount of interest that the lender has received on the loan. Borrowers who have paid more interest are generally considered to be less risky.

- total_rec_late_fee: This feature measures the total amount of late fees that the lender has received from the borrower. Borrowers who have paid fewer late fees are generally considered to be less risky.

- total_rec_prncp: This feature measures the total amount of principal that the lender has received from the borrower. Borrowers who have repaid more principal are generally considered to be less risky.
"""

from google.colab import drive
drive.mount('/content/drive')

"""# Libraries"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler, LabelEncoder, OneHotEncoder, normalize
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, precision_score, recall_score
from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error, roc_auc_score
import xgboost as xgb
from sklearn.impute import SimpleImputer
from sklearn.pipeline import Pipeline
from sklearn.svm import SVC
from sklearn import metrics

"""# Data Collection"""

pd.set_option('display.max_columns', None)

df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/VIX Rakamin/loan_data_2007_2014.csv')
df.head(2)

df.info()

df[['title','home_ownership','loan_status','loan_amnt','emp_title']]

"""# Data Cleaning

## Check Duplicated
"""

df.duplicated().sum()

"""## Drop Missing Values"""

missing_columns = ['addr_state','desc','earliest_cr_line','emp_length','emp_title','inq_last_6mths',
                  'issue_d','mths_since_last_delinq','mths_since_last_record','title','url','zip_code','id',
                  'Unnamed: 0']
df = df.drop(axis=1, columns=missing_columns)

df.isna().sum()

df.dropna()

"""## Correlated Columns"""

df = df.loc[:,['annual_inc','funded_amnt','grade','home_ownership','installment','int_rate','last_pymnt_amnt','loan_amnt','member_id','out_prncp_inv','purpose','recoveries','revol_util','term', 'total_pymnt','total_pymnt_inv','total_rec_int','total_rec_late_fee','total_rec_prncp']]

df.info()

df

df.describe()

df.corr()

corr = df.corr()
plt.figure(figsize=(20,15))
sns.heatmap(corr,annot=True)
plt.show()

"""# EDA

## Grade
LC assigned loan grades are a classification system used by some lenders to evaluate the creditworthiness of borrowers and the risk of default on loans. The grades range from A to G, with A being the highest quality loan and G being the lowest quality loan.


1. A: Excellent credit quality, very low risk of default
2. B: Good credit quality, low risk of default
3. C: Average credit quality, moderate risk of default
4. D: Below average credit quality, high risk of default
5. E: Poor credit quality, very high risk of default
6. F: Very poor credit quality, imminent risk of default
7. G: Unclassifiable
"""

df_grade = df.groupby('grade').agg({
    'member_id' : 'nunique'
}).reset_index()

df_grade.rename(columns={
    'member_id' : 'member_count'
}, inplace=True)

# df.groupby('grade').grade.count()

plt.figure(figsize=(10,5))

sns.barplot(
    y="member_count",
    x='grade',
    data = df_grade.sort_values(by='member_count', ascending=False)
)

plt.title("Number of Customers Grade", loc="center", fontsize=15)
plt.ylabel(None)
plt.xlabel(None)
plt.tick_params(axis='x', labelsize=12)
plt.show()

df_grade

"""## Homeowners
Homeowners may be less likely to default on loans because they have a stake in their property.


**Homeownership** is the act of owning a home. It is one of the most significant financial investments that a person can make. Homeowners can build equity in their homes over time, and they can also benefit from the tax advantages of homeownership.

**Mortgage** is a loan that is used to purchase a home. The borrower agrees to repay the loan over a period of time, typically with interest. The lender has a lien on the home, which means that they can foreclose on the home if the borrower defaults on the loan.

**Rent** is the monthly payment that a tenant makes to a landlord to live in a property. The rent payment typically covers the cost of housing, utilities, and maintenance.

**Own** a home means that you have legal title to the property and are responsible for all aspects of its ownership, including making mortgage payments, paying property taxes and insurance, and maintaining the property.
"""

df_home_ownership = df.groupby('home_ownership').agg({
    'member_id' : 'nunique'
}).reset_index()

df_home_ownership.rename(columns={
    'member_id' : 'member_count'
},inplace=True)

plt.figure(figsize=(10,5))

sns.barplot(
    y="member_count",
    x="home_ownership",
    data = df_home_ownership.sort_values(by='member_count', ascending=False)
)

plt.title("Number of Home Ownership", loc="center", fontsize=15)
plt.ylabel(None)
plt.xlabel(None)
plt.tick_params(axis='x', labelsize=12)
plt.show()

df_home_ownership

df.head(2)

df[['annual_inc','funded_amnt','home_ownership']].max()

"""# Feature Scaling & Encoding

## Scaling
"""

scaler = StandardScaler()
df[['annual_inc','funded_amnt','installment','int_rate','last_pymnt_amnt','loan_amnt','out_prncp_inv','recoveries','revol_util', 'total_pymnt','total_pymnt_inv','total_rec_int','total_rec_late_fee','total_rec_prncp']] = scaler.fit_transform(df[['annual_inc','funded_amnt','installment','int_rate','last_pymnt_amnt','loan_amnt','out_prncp_inv','recoveries','revol_util', 'total_pymnt','total_pymnt_inv','total_rec_int','total_rec_late_fee','total_rec_prncp']])

df.tail()

"""## Label Encoding

**grade**
- 0 : A
- 1 : B
- 2 : C
- 3 : D
- 4 : E
- 5 : F
- 6: G
"""

# encode = df[['grade','sub_grade','home_ownership','term']]
# encoder = LabelEncoder()
# df_encoded = encoder.fit(['grade','sub_grade','home_ownership','term'])
# encoded_data = encoder.transform(df_encoded)
# df_encoded = pd.DataFrame(encoded_data, columns=['grade','sub_grade','home_ownership','term'])
# df_encoded.tail()

# import  numpy as np
# encode = df[['grade','sub_grade','home_ownership','term']].values.ravel()
# encode = np.reshape(encode, (-1, 1))
# encoder = OneHotEncoder()
# # df_encoded = encoder.fit_transform(encode)
# # # Transform the data using the OneHotEncoder object
# df_encoded = encoder.fit_transform(encode.reshape(-1, 1))
# df_encoded = pd.DataFrame(df_encoded, columns=['grade','sub_grade','home_ownership','term'])
# df_encoded.tail()

encoder = LabelEncoder()
df['grade'] = encoder.fit_transform(df['grade'])
df.tail(2)

# df_encode_homeownership = encoder.fit_transform(df['home_ownership'])
# df_encode_homeownership = pd.DataFrame({"home_ownership": df_home_ownership})
# # df_encode_homeownership = df_encode_homeownership.reshape(-1, 1)
# # df_encode_homeownership = scaler.fit_transform(df['home_ownership'])
# df_encode_homeownership

# # df_encode_homeownership = np.expand_dims(df_encode_homeownership, axis=1)

# #df_encode_homeownership = pd.DataFrame({"home_ownership": df_home_ownership})

# # df_home_ownership.tail()

df['home_ownership'] = encoder.fit_transform(df['home_ownership'])
df['home_ownership'] = scaler.fit_transform(df[['home_ownership']])

df['term'] = encoder.fit_transform(df['term'])

df.head(2)

df['purpose'].unique()

"""# Data Modelling"""

X = df[['annual_inc','funded_amnt','installment','int_rate','last_pymnt_amnt','loan_amnt','out_prncp_inv','recoveries','revol_util', 'total_pymnt','total_pymnt_inv','total_rec_int','total_rec_late_fee','total_rec_prncp']]
Y = df['grade']

X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.20, random_state=42)

"""## XGBoost"""

xgb_model = xgb.XGBRegressor()
xgb_model = xgb_model.fit(X_train, y_train)
y_pred3 = xgb_model.predict(X_test)

"""## Decision Tree"""

imputer = SimpleImputer(strategy='median')
pipeline = Pipeline([('imputer', imputer), ('dt', DecisionTreeClassifier())])

pipeline.fit(X_train, y_train)

y_pred2 = pipeline.predict(X_test)

"""## Random Forest"""

imputer = SimpleImputer(strategy='median')
pipeline = Pipeline([('imputer', imputer), ('clf', RandomForestClassifier())])

pipeline.fit(X_train, y_train)

y_pred1 = pipeline.predict(X_test)

"""# Model Evaluation

## Errors
"""

accuracy = accuracy_score(y_test, y_pred2)
r2 = r2_score(y_test, y_pred2)
mae = mean_absolute_error(y_test, y_pred2)
mse = mean_squared_error(y_test, y_pred2)

print("="*10,"Decision Tree","="*10)
print('Accuracy :', accuracy)
print('R2 :', r2)
print('MAE :', mae)
print('MSE :', mse)

accuracy = accuracy_score(y_test, y_pred1)
r2 = r2_score(y_test, y_pred1)
mae = mean_absolute_error(y_test, y_pred1)
mse = mean_squared_error(y_test, y_pred1)

print("="*10,"Random Forest","="*10)
print('Accuracy :', accuracy)
print('R2 :', r2)
print('MAE :', mae)
print('MSE :', mse)

r2 = r2_score(y_test, y_pred3)
mae = mean_absolute_error(y_test, y_pred3)
mse = mean_squared_error(y_test, y_pred3)

print("="*10,"XGBoost Model","="*10)
print('R2 :', r2)
print('MAE :', mae)
print('MSE :', mse)